(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{267:function(t,e,o){"use strict";o.r(e);var r=o(28),c=Object(r.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"_19-computed-和-watch-的区别及运用场景"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_19-computed-和-watch-的区别及运用场景"}},[t._v("#")]),t._v(" 19. computed 和 watch 的区别及运用场景?")]),t._v(" "),o("hr"),t._v(" "),o("p",[o("strong",[t._v("区别")])]),t._v(" "),o("p",[o("strong",[t._v("computed：")]),t._v(" 计算属性。支持缓存，只有依赖的数据发生改变，才会重新进行计算。不支持异步，当computed内有异步操作时无效，无法监听数据的变化。"),o("br"),t._v(" "),o("strong",[t._v("watch：")]),t._v(" 侦听属性。不支持缓存，数据变，直接会触发相应的操作，支持异步。监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值。")]),t._v(" "),o("p",[o("strong",[t._v("运用场景")])]),t._v(" "),o("p",[o("strong",[t._v("computed：")]),t._v(" 当我们需要进行数值计算,并且依赖于其它数据时,应该使用 computed,因为可以利用 computed 的缓存特性,避免每次获取值时,都要重新计算。"),o("br"),t._v(" "),o("strong",[t._v("watch：")]),t._v(" 当我们需要在数据变化时执行异步操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。")])])}),[],!1,null,null,null);e.default=c.exports}}]);